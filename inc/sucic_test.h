#ifdef SUCIC_TEST_ENABLED

#ifndef SUCIC_SUCIC_TEST_H
#define SUCIC_SUCIC_TEST_H

#include <stdint.h>

// https://medium.com/@zlhk100/openssl-for-iot-system-security-development-series-part-2-how-to-convert-raw-nist-secp256r1-f8f0939aa6d3
// echo 30310201010420F1AB1074477EBCC7F554EA1C5FC368B1616730155E0041AC447D6301975FECDAa00a06082a8648ce3d030107 | xxd -r -p > ec-priv-hnkey.der

#define TEST_PRIV_HNKEY_FILE "res/ec-priv-hnkey.der"

static uint8_t hn_privkey_bytes_test[51] = {
        0x30, 0x31, 0x02, 0x01, 0x01, 0x04, 0x20,           // header
        0xF1, 0xAB, 0x10, 0x74, 0x47, 0x7E, 0xBC, 0xC7,     // key
        0xF5, 0x54, 0xEA, 0x1C, 0x5F, 0xC3, 0x68, 0xB1,
        0x61, 0x67, 0x30, 0x15, 0x5E, 0x00, 0x41, 0xAC,
        0x44, 0x7D, 0x63, 0x01, 0x97, 0x5F, 0xEC, 0xDA,
        0xa0, 0x0a, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce,     // OID params indicate secp256r1
        0x3d, 0x03, 0x01, 0x07
};

static uint8_t priv_bytes_test[512] = { //32
        0xF1, 0xAB, 0x10, 0x74, 0x47, 0x7E, 0xBC, 0xC7,
        0xF5, 0x54, 0xEA, 0x1C, 0x5F, 0xC3, 0x68, 0xB1,
        0x61, 0x67, 0x30, 0x15, 0x5E, 0x00, 0x41, 0xAC,
        0x44, 0x7D, 0x63, 0x01, 0x97, 0x5F, 0xEC, 0xDA
};

static int priv_bytes_len = 32;

/*uint8_t suci_uepubkey_bytes[512] = { //33
        0x03, 0x08, 0x25, 0x5c, 0xd6, 0x3e, 0x72, 0x78,
        0xf0, 0x35, 0x32, 0x04, 0x2f, 0x99, 0xfb, 0x6e,
        0xb2, 0x8e, 0x3a, 0xab, 0x4a, 0x86, 0xe5, 0x4c,
        0xfe, 0xb8, 0xd1, 0xe2, 0xcf, 0xc1, 0x66, 0x50,
        0x69
};

int suci_uepubkey_bytes_len = 33;*/

// https://www.ietf.org/rfc/rfc5480.txt
// echo 3039301306072A8648CE3D020106082A8648CE3D030107032200039AAB8376597021E855679A9778EA0B67396E68C66DF32C0F41E9ACCA2DA9B9D1 | xxd -r -p > ec-pub-uekeysample.der
static uint8_t ue_pubkey_bytes_test[39] = {
//        0x30, 0x59,           // uncompressed total = 91
        0x30, 0x39,     // compressed total = 39
        0x30, 0x13, 0x06, 0x07,
        0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x02, 0x01,
        0x06, 0x08,
        0x2A, 0x86, 0x48,0xCE,0x3D, 0x03, 0x01,  // ECC: 2A 86 48 CE 3D 02 01
        0x07, 0x03,
        0x22, 0x00,                               // header len compressed


/*      0x42, 0x00,                                         // header len uncompressed
        0x04, 0x9A, 0xAB, 0x83, 0x76, 0x59, 0x70, 0x21,     // key uncompressed
        0xE8, 0x55, 0x67, 0x9A, 0x97, 0x78, 0xEA, 0x0B,
        0x67, 0x39, 0x6E, 0x68, 0xC6, 0x6D, 0xF3, 0x2C,
        0x0F, 0x41, 0xE9, 0xAC, 0xCA, 0x2D, 0xA9, 0xB9,
        0xD1, 0xD1, 0xF4, 0x4E, 0xA1, 0xC8, 0x7A, 0xA7,
        0x47, 0x8B, 0x95, 0x45, 0x37, 0xBD, 0xE7, 0x99,
        0x51, 0xE7, 0x48, 0xA4, 0x32, 0x94, 0xA4, 0xF4,
        0xCF, 0x86, 0xEA, 0xFF, 0x17, 0x89, 0xC9, 0xC8,
        0x1F */

        0x03, 0x9A, 0xAB, 0x83, 0x76, 0x59, 0x70, 0x21,   // pubkey compressed sample
        0xE8, 0x55, 0x67, 0x9A, 0x97, 0x78, 0xEA, 0x0B,
        0x67, 0x39, 0x6E, 0x68, 0xC6, 0x6D, 0xF3, 0x2C,
        0x0F, 0x41, 0xE9, 0xAC, 0xCA, 0x2D, 0xA9, 0xB9,
        0xD1

/*        0x03, 0x08, 0x25, 0x5c, 0xd6, 0x3e, 0x72, 0x78,     // pubkey live device
        0xf0, 0x35, 0x32, 0x04, 0x2f, 0x99, 0xfb, 0x6e,
        0xb2, 0x8e, 0x3a, 0xab, 0x4a, 0x86, 0xe5, 0x4c,
        0xfe, 0xb8, 0xd1, 0xe2, 0xcf, 0xc1, 0x66, 0x50,
        0x69
        */
};

static uint8_t ue_pubkey_rawbytes_test[33] = {
        0x03, 0x9A, 0xAB, 0x83, 0x76, 0x59, 0x70, 0x21,   // pubkey compressed sample
        0xE8, 0x55, 0x67, 0x9A, 0x97, 0x78, 0xEA, 0x0B,
        0x67, 0x39, 0x6E, 0x68, 0xC6, 0x6D, 0xF3, 0x2C,
        0x0F, 0x41, 0xE9, 0xAC, 0xCA, 0x2D, 0xA9, 0xB9,
        0xD1
};

static unsigned char profileb_ciphertext_test[5] = {
        0x46, 0xA3, 0x3F, 0xC2, 0x71
};

#endif // SUCIC_SUCIC_TEST_H

#endif // SUCIC_TEST_ENABLED